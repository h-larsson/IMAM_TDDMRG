#! /usr/bin/env python

import os, sys, time
from functools import reduce
from humanfriendly import format_timespan
import numpy as np
from pyscf import gto
from pyscf.tools import cubegen
from orbs_gen import get_rhf_orbs, get_casscf_orbs, get_dft_orbs
from get_orbs_input import get_inputs
from util_orbs import sort_similar
from orbs_generate.analyze_orbs import analyze, analyze_multipole, analyze_population
from local_orbs import localize
from IMAM_TDDMRG.utils.util_print import print_warning


t_start = time.time()

######################
#vvvv Input File vvvv#
######################
import sys
inp_file = str(sys.argv[1])
inputs = get_inputs(inp_file)
if inputs['dump_inputs']:
    print('\nInput parameters:')
    for kw in inputs:
        print('  ', kw, ' = ', inputs[kw])
    print(' ')
######################
#^^^^ Input File ^^^^#
######################



#==== Setting up the system ====#
mol = gto.M(atom=inputs['inp_coordinates'], basis=inputs['inp_basis'], ecp=inputs['inp_ecp'],
            symmetry=inputs['inp_symmetry'], charge=inputs['charge'], spin=inputs['twosz'])
na, nb = mol.nelec
pg = mol.groupname.lower()
n_mo = mol.nao
ovl = mol.intor('int1e_ovlp')
print('Point group = ', mol.groupname)
print('Charge = ', mol.charge)
print('Number of electrons (alpha, beta, total) = ' +
      f'{mol.nelec[0]}, {mol.nelec[1]}, {mol.nelectron}')
print('Number of AO bases = ', mol.nao)
print('Number of MO bases = ', n_mo)
save_prefix = inputs['save_dir'] + '/' + inputs['prefix']

#==== Generate orbitals based on the chosen method ====#
#==== HF ====#
if inputs['source'] == 'rhf':
    outs = get_rhf_orbs(mol, True, inputs['conv_tol'], inputs['natorb'])
    orbs = outs['orbs']
    occs = outs['occs']
    ergs = outs['ergs']
    try:
        rdm = outs['rdm']
    except KeyError:
        rdm = None
        print(' >>> ATTENTION <<<')
        print('   The RDM from the Hartree-Fock calculation will not be saved.')

        
#==== CASSCF ====#
elif inputs['source'] == 'casscf':
    init_orbs_ = np.load(inputs['init_orbs'])

    dmrg_nthreads = int(os.environ.get("OMP_NUM_THREADS", 1))
    outs = get_casscf_orbs(
        mol, inputs['nCAS'], inputs['nelCAS'], init_orbs_, inputs['frozen'], 
        inputs['ss'], inputs['ss_shift'], inputs['twosz'], inputs['wfnsym'], inputs['natorb'], 
        inputs['init_basis'], inputs['state_average'], inputs['sa_weights'],
        inputs['sort_out'], True, 2, inputs['conv_tol'], inputs['fcisolver'],
        inputs['max_bond_dim'], inputs['sweep_tol'], dmrg_nthreads)
    orbs = outs['orbs']
    occs = outs['occs']
    try:
        ergs = outs['ergs']
    except KeyError:
        ergs = None
        print(' >>> ATTENTION <<<')
        print('   The energies from the CASSCF calculation will not be saved.')
    try:
        rdm = outs['rdm']
    except KeyError:
        rdm = None
        print(' >>> ATTENTION <<<')
        print('   The RDM from the CASSCF calculation will not be saved.')
    if inputs['state_average']:
        try:
            rdm_states = outs['rdm_states']
        except KeyError:
            rdm_states = None
            print(' >>> ATTENTION <<<')
            print('   State averaging is active but the RDMs of the individual states ' +
                  'in the ensemble will not be saved.')


#==== DFT ====#
elif inputs['source']  == 'dft':
    outs = get_dft_orbs(mol, inputs['xc'], inputs['conv_tol'], True, inputs['natorb'])
    orbs = outs['orbs']
    occs = outs['occs']
    ergs = outs['ergs']
    try:
        rdm = outs['rdm']
    except KeyError:
        rdm = None
        print(' >>> ATTENTION <<<')
        print('   The RDM from the DFT calculation will not be saved.')

else:
    pass



#==== Localization ====#
if inputs['localize']:
    # inputs['loc_subs'] is a list of lists of integers. These integers define the base-1 ID
    # of the localized orbitals for each subspace.

    # Below, the localization algorithm will prioritize loading the input orbitals from
    # the input keyword 'orbs_for_loc'. Meaning that if there is also computation of
    # orbitals from a source above, these orbitals will be ignored and overwritten.
    #== Try to assign orbitals to be localized ==#
    try:
        orbs = np.load(inputs['orbs_for_loc'])
        orbs_init = orbs.copy()
    except (FileNotFoundError, KeyError):
        try:      # 1)
            orbs_init = orbs.copy()
        except NameError:
            raise RuntimeError('get_orbs: There is no input orbitals found to be localized.')
    # 1) Successful if a previous SCF calculations in the same run outputs orbitals.
    
    #== Try to assign RDM needed for the occupations of localized orbs ==#
    try:
        rdm_init = np.load(inputs['rdm_for_loc'])
    except (FileNotFoundError, KeyError):
        if inputs['state_averaging']:
            print_warning('When localizing orbitals, using an RDM from a preceding ' + \
                          'calculation in the same run, and state averaging is active, ' + \
                          'the RDM that will be used by the localization algorithm ' + \
                          'is the total ensemble RDM. If you want to use one of the ' + \
                          'RDM of the individual ensemble states, use the input ' + \
                          'keyword \'rdm_for_loc\' to specify the path of the desired ' + \
                          'RDM already existing in the disk (a prior calculation is ' +
                          'required).')
        try:
            rdm_init = rdm
        except NameError:
            rdm_init = None
            
    #== If occupations-based localization subspace is requested ==#
    if inputs['loc_type'] == 'DEFINE_LATER':
        inputs['loc_type'] = None
    if inputs['loc_irrep'] == 'DEFINE_LATER':
        inputs['loc_irrep'] = None
    outs = localize(mol, orbs_init, rdm_init, ovl, inputs['loc_subs'],
                    inputs['loc_occs'], inputs['loc_type'], inputs['loc_irrep'],
                    inputs['loc_exclude'])

    #== Outputs ==#
    orbs = outs['orbs']
    occs = outs['occs']
    ergs = None
    trans_loc = outs['coef']
    np.save(save_prefix + '.loc', trans_loc)
    if rdm_init is not None:
        rdm = outs['rdm']
    else:
        rdm = None
        print(' >>> ATTENTION <<<')
        print('   The RDM from orbitals localization will not be saved.')

        
#==== Similarity sorting ====#
if inputs['sort_ref'] is not None:
    osort_ref = np.load(inputs['sort_ref'])
    orbs, idsort = sort_similar(orbs, osort_ref, ovl, inputs['similar_thr'],
                                inputs['dissimilar_break'])
    if occs is not None: occs = occs[idsort]    
    if ergs is not None: ergs = ergs[idsort]

#==== Ensure that the output orbitals are orthonormal ====#
itest = orbs.T @ ovl @ orbs
nn = orbs.shape[0]
dg = np.diag(itest).copy()    # Extract the diagonal element of itest.
sum_diag = np.sum(dg)
sum_ndiag = np.sum(itest-np.diag(dg)) / (nn*(nn-1))
#fordebug print('ortho', sum_diag, sum_ndiag)
assert abs(sum_diag - nn) < 1.0E-12 and abs(sum_ndiag) < 1.0E-12, \
    'ERROR: Output orbitals are not orthonormal.'
           
#==== Analyze the final orbitals ====#
print('\n\nOrbital occupations, energies, and symmetries:')
analyze(mol, orbs, occs, ergs)
print('\n\nOrbital multipole components:')
analyze_multipole(mol, orbs)
print('\n\nOrbital atomic populations:')
analyze_population(mol, orbs, 'low')


#==== Save final orbitals ====#
np.save(save_prefix + '.orb', orbs)


#==== Save final occupations ====#
if occs is not None:
    np.save(save_prefix + '.occ', occs)
    print('\n *** INFO***')
    print('   Occupation vector has been saved to ' + save_prefix + '.occ.npy')
else:
    print('\n >>> ATTENTION <<<')
    print('   No occupation vector to be saved. **BE WARNED** that if an occupation ' + \
          'vector file is pre-existing in the same diractory, its occupation\n' + \
          '   values may not correspond to the same parameters used in the current ' + \
          'simulation.')


#==== Save final energies ====#
if ergs is not None:
    np.save(save_prefix + '.erg', ergs)
    print('\n *** INFO***')
    print('   Energy vector has been saved to ' + save_prefix + '.erg.npy')
else:
    print('\n >>> ATTENTION <<<')
    print('   No energy vector to be saved. **BE WARNED** that if an energy ' + \
          'vector file is pre-existing in the same diractory, its energy\n' + \
          '   values may not correspond to the same parameters used in the current ' + \
          'simulation.')

    
#==== Save final RDM ====#
if rdm is not None:
    np.save(save_prefix + '.rdm', rdm)
    print('\n *** INFO***')
    print('   RDM array in MO basis has been saved to ' + save_prefix + '.rdm.npy')
else:
    print('\n >>> ATTENTION <<<')
    print('   No RDM array to be saved. **BE WARNED** that if an RDM array file ' + \
          'is pre-existing in the same diractory, its RDM values may not correspond \n' + \
          '   to the same parameters used in the current simulation.')
if inputs['state_average']:
    if rdm_states is not None:
        np.save(save_prefix + '.rdm_sa', rdm_states)
        print('\n *** INFO***')
        print('   RDM_states array in MO basis has been saved to ' + save_prefix + '.rdm_sa.npy')
    else:
        print('\n >>> ATTENTION <<<')
        print('   No RDM_states array to be saved. **BE WARNED** that if an RDM_states array file ' + \
              'is pre-existing in the same diractory, its RDM_states values may not correspond \n' + \
              '   to the same parameters used in the current simulation.')    

print('')
t_fin = time.time()
print('Total computational time = ' + format_timespan(t_fin-t_start, max_units=5))
print('\n\n')
