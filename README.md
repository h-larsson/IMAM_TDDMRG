

# TDDMRG-CM

TDDMRG-CM is a Python program designed to make the workflow of simulating charge migration using the time-dependent density matrix renormalization group (TDDMRG) easy and straightforward. It consists of three main functionalities: ground state DMRG, application of annihilation operator, and time evolution using TDDMRG. This program is built on top of BLOCK2 (https://github.com/block-hczhai/block2-preview) and PySCF (https://github.com/pyscf/pyscf), therefore, these two programs must already be installed before using TDDMRG-CM.

To run the program, you need to prepare an input file. The input parsing environment of TDDMRG-CM has been designed so that input files are essentially a normal Python `*.py` file.  This offers high flexibility for users in providing the values of input parameters to the program. Since it is an ordinary Python file, you can write the code to calculate the value of a certain input parameter right inside the input file. As an example, you want to initiate the ground state DMRG iterations from an MPS having a certain set of orbital occupancies (see `gs_occs` input definition below), and these occupancies are obtained from a separate quantum chemistry calculation. Let's say that this other calculation returns a one-particle reduced density matrix (RDM) as a matrix named `rdm.npy` in the parent folder. Then, you can give a value to the `gs_occs` input parameter in the following manner inside your input file.
```python
import numpy as np
...
rdm = np.load('../rdm.npy')
gs_occs = np.diag(rdm)
...
```
The program views the variable `rdm` as an intermediate variable, and hence will not be affected by it nor aborts even though it is an unrecognized input variable. The downside of the above input design, however, is that any syntactical error inside the input file is not always indicated with the location where it happens.

## Ground state DMRG

This task computes the ground state energy using DMRG algorithm and optionally saves the final ground state MPS. The Python script below shows an example of a simple ground state calculation of the water molecule using TDDMRG-CM
```python

complex_MPS_type = 'hybrid'
prefix = 'H2O'
atoms = \
            '''
            O   0.000   0.000   0.107;
            H   0.000   0.785  -0.427;
            H   0.000  -0.785  -0.427;
            '''
basis = 'cc-pvdz'
group = 'C2v'
wfn_sym = 'A1'
orb_path = '/<absolute>/<path>/<to>/<orbital>/H2O.orb.npy'

nCore = 1
nCAS = 23
nelCAS = 8
twos = 0

do_groundstate = True
if do_groundstate:
    D_gs = [100]*4 + [250]*4 + [400]
    gs_outmps_dir = './' + prefix + '.gs-mps'

do_annihilate = False
do_timeevo = False
```
Here, it is assumed that some orbitals have previously been calculated and are stored in a numpy file whose full path is `/<absolute>/<path>/<to>/<orbital>/H2O.orb.npy`. We highly recommend to use an absolute path rather than a relative path for `orb_path` input parameter. This is because this parameter will be stored in a logbook file (see below) with the value as is. If a subsequent simulation located in a different directory wants to use the same orbital by specifying the logbook generated by the simulation above, a file-not-found error will ensue since the relative path does not apply for the location of the new simulation.

The output of this calculation contains a line that shows the final ground state energy
```
 Ground state energy =   -76.2393734097
```
Some of the first micro iterations in the 11-th macro iteration (denoted by `Sweep = ...`) should look like
```
Sweep =   11 | Direction = backward | Bond dimension =  400 | Noise =  0.00e+00 | Dav threshold =  1.00e-06
 <-- Site =   21-  22 .. 
     1     1     0   -24.15991433     1.47e-11
Mmps =    3 Ndav =   1 E =    -76.2393711185 Error = 0.00e+00 FLOPS = 3.41e+05 Tdav = 0.00 T = 0.01
 <-- Site =   20-  21 .. 
     1     1     0   -24.15991433     5.29e-08
Mmps =   10 Ndav =   1 E =    -76.2393711185 Error = 0.00e+00 FLOPS = 1.38e+07 Tdav = 0.00 T = 0.01
 <-- Site =   19-  20 .. 
     1     1     0   -24.15991433     5.48e-07
Mmps =   35 Ndav =   1 E =    -76.2393711185 Error = 0.00e+00 FLOPS = 2.50e+08 Tdav = 0.00 T = 0.01
 <-- Site =   18-  19 .. 
     1     1     0   -24.15991433     8.96e-07
Mmps =  118 Ndav =   1 E =    -76.2393711185 Error = 1.80e-45 FLOPS = 3.17e+09 Tdav = 0.01 T = 0.02
 <-- Site =   17-  18 .. 
     1     1     0   -24.15991433     9.64e-07
Mmps =  246 Ndav =   1 E =    -76.2393711185 Error = 8.18e-40 FLOPS = 1.09e+10 Tdav = 0.01 T = 0.03
 <-- Site =   16-  17 .. 
     1     1     0   -24.15991433     1.47e-07
Mmps =  298 Ndav =   1 E =    -76.2393711185 Error = 0.00e+00 FLOPS = 5.87e+09 Tdav = 0.07 T = 0.10
 <-- Site =   15-  16 .. 
     1     1     0   -24.15991433     1.72e-07
Mmps =  400 Ndav =   1 E =    -76.2393711185 Error = 3.80e-37 FLOPS = 8.49e+09 Tdav = 0.14 T = 0.19
 <-- Site =   14-  15 .. 
     1     1     0   -24.15991433     1.97e-06
     2     2     0   -24.15991449     2.91e-08
Mmps =  400 Ndav =   2 E =    -76.2393712705 Error = 1.18e-08 FLOPS = 9.65e+09 Tdav = 0.40 T = 0.48
 <-- Site =   13-  14 .. 
     1     1     0   -24.15991433     2.61e-05
     2     2     0   -24.15991662     6.78e-07
Mmps =  400 Ndav =   2 E =    -76.2393734097 Error = 2.03e-07 FLOPS = 9.64e+09 Tdav = 0.79 T = 0.88
 <-- Site =   12-  13 .. 
     1     1     0   -24.15991434     2.06e-05
     2     2     0   -24.15991604     3.15e-07
```
Note that the bond dimensions between the sites from the last site (the sites are denoted by `<-- Site = ...` increases up to 400 and stays constant afterwards. This is because the bond dimension schedule (`D_gs`) has been set to be stay at 400 starting from the 9-th macro iteration, while the snippet above shows the 13-th macro iteration.

At the end of the calculation, several standard quantum chemical quantities are printed, such as orbital occupancies, multipole moments, and bond orders of some significant bonds
```
  *** Molecular orbitals occupations (alpha, beta) ***
  *** Molecular orbitals occupations (alpha, beta) ***
      (1: 1.000000, 1.000000)   (2: 0.991053, 0.991053)   (3: 0.981319, 0.981319)   (4: 0.983570, 0.983570)   (5: 0.985799, 0.985799)   
      (6: 0.004947, 0.004947)   (7: 0.005064, 0.005064)   (8: 0.006625, 0.006625)   (9: 0.006228, 0.006228)   (10: 0.006486, 0.006486)   
      (11: 0.008741, 0.008741)   (12: 0.003715, 0.003715)   (13: 0.001840, 0.001840)   (14: 0.002151, 0.002151)   (15: 0.001196, 0.001196)   
      (16: 0.002363, 0.002363)   (17: 0.000313, 0.000313)   (18: 0.001442, 0.001442)   (19: 0.001623, 0.001623)   (20: 0.001440, 0.001440)   
      (21: 0.001302, 0.001302)   (22: 0.001130, 0.001130)   (23: 0.000842, 0.000842)   (24: 0.000812, 0.000812)   
 
  *** Atomic Mulliken populations ***
      (O1: -0.275821)   (H2: 0.137910)   (H3: 0.137910)   
 
  *** Atomic Lowdin populations ***
      (O1: -0.065060)   (H2: 0.032530)   (H3: 0.032530)   
 
  *** Mulliken bond orders ***
     Atom A    Atom B    Bond order
          1         2      0.978000
          1         3      0.978000
   Note: Only bonds for which the bond order is larger than 0.1 are printed.
 
  *** Lowdin bond orders ***
     Atom A    Atom B    Bond order
          1         2      1.158799
          1         3      1.158799
   Note: Only bonds for which the bond order is larger than 0.1 are printed.
 
  *** Multipole moment components ***
                        x            y            z            xx           yy           zz           xy           yz           xz     
     Electronic     -0.000000     0.000000    -0.723955    -5.240511    -7.391749    -6.191456    -0.000000    -0.000000    -0.000000
     Nuclear         0.000000     0.000000     0.003779     0.000000     4.401159     1.629298     0.000000     0.000000     0.000000
     Total           0.000000     0.000000    -0.720176    -5.240511    -2.990590    -4.562158     0.000000    -0.000000     0.000000
```

At several instances during the program execution (including when it is finished), a logbook file `*.lb` is created and updat
ed. A logbook file stores information about the value of many variables (including input parameters) generated during a job. This file serves a similar purpose as Gaussian checkpoint files or NWChem's RTDB file, and other quantum chemistry program's auxiliary files that provide transferrability of data between different simulations or simulation components.


## Annihilation operator
Since charge migration happens in an ionized state, an important component of TDDMRG-CM is the application of annihilation operator to the MPS of an un-ionized state. The Python script below is an example of input file for annihilation operator task where the input MPS is the ground state MPS calculated above. Before creating this input file for annihilation task, make a directory under the directory of the ground state calculation previously, then create the input file under this new directory.
```python
import numpy as np

prefix = 'H2O'
GS_PATH = '..'
prev_logbook = GS_PATH + '/H2O.lb'
complex_MPS_type = 'logbook'

atoms = 'logbook'
basis = 'logbook'
group = 'logbook'
wfn_sym = 'logbook'
orb_path = 'logbook'
orb_order = 'logbook:orb_order_id'

nCore = 'logbook'
nCAS = 23
nelCAS = 'logbook'
twos = 'logbook'

do_groundstate = False

do_annihilate = True
if do_annihilate:
    ann_sp = True
    ann_orb = np.zeros(nCAS)
    ann_orb[3] = ann_orb[9] = 1/np.sqrt(2)
    D_ann_fit = [100]*4 + [300]*4 + [500]*4 + [800]*4 + [600]*4 + [400]
    ann_inmps_dir = GS_PATH + '/H2O.gs-mps'
    ann_outmps_dir = './' + prefix + '.ann-mps'

do_timeevo = False
```
The input file above extensively utilizes the logbook file created from the previous ground state calculation. The lines
```python
GS_PATH = '..'
prev_logbook = GS_PATH + '/H2O.lb'
```
which result in `prev_logbook = '../H2O.lb'` tells the program to load the logbook file located under the parent directory to be used as a reference for several input parameters in the current input file. Input parameters assigned with `'logbook'` will take the value of the corresponding input parameters stored in the specified logbook file. For example, in the above input `basis` and `wfn_sym` will be assigned with `'cc-pvdz'` and `'A1'`, respectively. The use of logbook file is highly encouraged since it minimizes accidental errors in providing the correct value to some input parameters.

Orbital ordering for annihilation task should be the same as the ordering of orbitals in the input MPS, which was in turn calculated during a ground state task. This why we have used `orb_order = 'logbook:orb_order_id'`. Note that the assigned value is not just `'logbook'`---had we used this, the program will pull an entry named `'orb_order'` from the loaded logbook, whose value is `'genetic'`, as calculated during the previous ground state task, and will prompt the program to recalculate the ordering using the genetic algorithm. The use of `X = 'logbook:var_name'` means that the program pulls the value of a variable named `var_name` and assigns it to the variable `X`. In our example, we are looking for a variable named `orb_order_id` because this variable stores the ordering indices calculated during the previous ground state simulation. TDDMRG-CM provides several utility functions to analyze or preview the content of a logbook file. See the example below.
```python
from TDDMRG_CM.utils import util_logbook
lb = util_logbook.read('H2O.lb')     # Loading a logbook given its path.
util_logbook.content(lb)             # Print the content of logbook.
```
Note that once loaded using `util_logbook.read`, a logbook is essentially a Python dictionary, so you can perform any operations defined for a dictionary on `lb`.

The parameter `nCAS` is given an explicitly typed value instead of the string `'logbook'` even though the loaded logbook has an information about it. This is because `nCAS` is used further down for constructing `ann_orb`. This is an example of exceptions in which you should not use the value from a logbook file.

In the above input for annihilation operator task, an electron is annihilated from an orbital whose coefficient in the basis of the site orbitals are given by `ann_orb`. Since it contains zeros except for the 3rd and 9th elements, which are equal to `np.sqrt(2)`, the annihilation orbital is thus an in-phase, equal-strength superposition between Hartree-Fock HOMO (index `3`) and LUMO+5 (index `9`). The output of annihilation operator task contains the following table in the beginning of the simulation.
```
 Occupations before annihilation:
 ---------------------------------------------------------------------------------------------------
  No.    Alpha MO occ.    Beta MO occ.    Irrep / ID    aorb coeff     Alpha natorb occ.   Beta natorb occ.
 ---------------------------------------------------------------------------------------------------
    0       0.99105259      0.99105259        A1 / 0    0.00000000            0.99196709         0.99196709
    1       0.98131860      0.98131860        B2 / 3    0.00000000            0.98580737         0.98580737
    2       0.98356961      0.98356961        A1 / 0    0.00000000            0.98276444         0.98276444
    3       0.98579937      0.98579937        B1 / 2    0.70710678            0.98139798         0.98139798
    4       0.00494665      0.00494665        A1 / 0    0.00000000            0.01348813         0.01348813
    5       0.00506351      0.00506351        B2 / 3    0.00000000            0.01291446         0.01291446
    6       0.00662521      0.00662521        B2 / 3    0.00000000            0.00884486         0.00884486
    7       0.00622765      0.00622765        A1 / 0    0.00000000            0.00618726         0.00618726
    8       0.00648558      0.00648558        A1 / 0    0.00000000            0.00308791         0.00308791
    9       0.00874101      0.00874101        B1 / 2    0.70710678            0.00303757         0.00303757
   10       0.00371483      0.00371483        B2 / 3    0.00000000            0.00273979         0.00273979
   ...
   ...
   21       0.00084233      0.00084233        A1 / 0    0.00000000            0.00003464         0.00003464
   22       0.00081188      0.00081188        B2 / 3    0.00000000            0.00002364         0.00002364
 ---------------------------------------------------------------------------------------------------
  Sum       4.00000000      4.00000000                                        4.00000000         4.00000000
 ---------------------------------------------------------------------------------------------------
```
This table lists the occupancies of the site orbitals (2nd and 3rd columns), the irrep type and index of the corresponding site orbital (4th column), orbital coefficients in the `ann_orb` (5th column), and the occupancies of natural orbitals (6th and 8th columns) in the input MPS. The last row displays the number of electrons in each spin channel, which must equal the value assigned to `nelCAS`.
```
 Occupations after annihilation:
 ---------------------------------------------------------------------------------------------------
  No.    Alpha MO occ.    Beta MO occ.    Irrep / ID    aorb coeff     Alpha natorb occ.   Beta natorb occ.
 ---------------------------------------------------------------------------------------------------
    0       0.99140248      0.99140248        A1 / 0    0.00000000            0.99264465         0.99264465
    1       0.98231103      0.98231103        B2 / 3    0.00000000            0.98441170         0.98441170
    2       0.98464807      0.98464807        A1 / 0    0.00000000            0.98303153         0.98303153
    3       0.49449454      0.49449454        B1 / 2    0.70710678            0.49559134         0.49559134
    4       0.00412045      0.00412045        A1 / 0    0.00000000            0.01246532         0.01246532
    5       0.00455988      0.00455988        B2 / 3    0.00000000            0.01142285         0.01142285
    6       0.00605761      0.00605761        B2 / 3    0.00000000            0.00521137         0.00521137
    7       0.00535028      0.00535028        A1 / 0    0.00000000            0.00335203         0.00335203
    8       0.00621465      0.00621465        A1 / 0    0.00000000            0.00264789         0.00264789
    9       0.00434197      0.00434197        B1 / 2    0.70710678            0.00252970         0.00252970
   10       0.00378889      0.00378889        B2 / 3    0.00000000            0.00154977         0.00154977
   ...
   ...
   21       0.00061853      0.00061853        A1 / 0    0.00000000            0.00001883         0.00001883
   22       0.00078966      0.00078966        B2 / 3    0.00000000            0.00001837         0.00001837
 ---------------------------------------------------------------------------------------------------
  Sum       3.50000000      3.50000000                                        3.50000000         3.50000000
 ---------------------------------------------------------------------------------------------------
```
Toward the end of the output, you will also find a similar table except that now the occupancies are calculated with respect to the output MPS resulting from the action of the annihilation operator on the input MPS. As can be seen, the total occupancy of the 3rd site orbital (HOMO) has been reduced by about one. The total number of electrons after annihilation process is seen to be exactly equal to `nelCAS-1`.

Near the beginning, you can find the information about the quantum numbers of the input and output MPSs. In the above simulation, this part looks like
```
 Quantum number information:
  - Input MPS =  < N=8 S=0 PG=0 >
  - Input MPS multiplicity =  1
  - Annihilated orbital =  < N=-1 S=1/2 PG=2 >
  - Output MPS =  < N=7 S=1/2 PG=2 >
  - Output MPS multiplicity =  2
```
`N`, `S`, and `PG` stand for the number of electros, the total spin, and irrep type of the MPS. Here, we see that the input MPS has 8 active electrons, is a singlet state, and has the $A_1$ (ID 0) irrep. The annihilated orbital is defined to have `-1` number of electrons. In particular, its irrep is equal to `2`, which corresponds to the $B_1$ irrep of the $C_{2v}$ point group. Also note that the two orbitals, HOMO and LUMO+5, making up the linear combination of the annihilated orbital, have the same symmetry. This is necessary, otherwise an error will occur. If you need to have an annihilated orbital that is a linear combination of site orbitals of different irreps, then you need to choose an appropriate point group for input parameter `group` that identifies the orbitals in the linear combination as belonging to the same point group. The output MPS has 7 electrons, a total spin of one-half, and irrep type of $B_1$. The irrep of the output MPS can be determined through the irrep direct product property.

In the input file for annihilation operator task above, the bond dimension schedule has been given values that initially increase from `100` to `800` and then decrease to the final value of `400`. The overshot to the maximum value of `800` instead of increasing and stopping at the final desired value of `400` allows the MPS fitting algorithm to search for the minimum (the solution output MPS) in a larger Hilbert space. Repeating the simulation with a bond dimension schedule that exhibits no overshot as `D_ann_fit = [100]*4 + [300]*4 + [400]` results in a less accurate output MPS as demonstrated by the final electron number of `3.49999942 * 2 = 6.99999884` that is less close to the proper value of 7 than previously. See occupancy table below.
```
 Occupations after annihilation:
 ---------------------------------------------------------------------------------------------------
  No.    Alpha MO occ.    Beta MO occ.    Irrep / ID    aorb coeff     Alpha natorb occ.   Beta natorb occ.
 ---------------------------------------------------------------------------------------------------
   ...
   ...
   21       0.00061854      0.00061854        A1 / 0    0.00000000            0.00001882         0.00001882
   22       0.00078963      0.00078963        B2 / 3    0.00000000            0.00001841         0.00001841
 ---------------------------------------------------------------------------------------------------
  Sum       3.49999942      3.49999942                                        3.49999942         3.49999942
 ---------------------------------------------------------------------------------------------------
 ```

The output MPS above has a non-zero total spin (non-singlet) as necessitated by the odd number of electrons it has. In MPS framework, it is possible to represent a non-singlet MPS as a singlet MPS, this is referred to as singlet-embedding. In TDDMRG-CM, to convert a non-singlet output MPS of annihilation operator task, switch singlet embedding on using the `ann_out_singlet_embed` input parameter.
```
...
...
do_annihilate = True
if do_annihilate:
    ...
    ann_out_singlet_embed = True
```
Using singlet-embedded MPS for a non-singlet MPS for time evolution using TDDMRG is highly recommended as has been shown in [this publication](https://arxiv.org/abs/2409.05959v2).

As also shown in the cited publication above, using full complex MPS type in TDDMRG time evolution rather than the hybrid one is much more favorable due to the faster convergence with bond dimension. Performing ground state and annihilation operator calculations in the full complex mode where the MPSs are complex is possible by setting `complex_MPS_type = 'full'`. While this should yield exactly the same results, this is redundant since these calculations do not necessitate a complex wave function. A much more efficient way is to convert the output MPS from annihilation task run in a `'hybrid'` mode to a full complex MPS form. This is done by setting `ann_out_cpx = True`.


## Time Evolution


## Logbook - starting a job based on a previous calculation

## Probe file


## Input parameters






#==== General parameters ====#
<details>
  <summary><code>atoms</code></summary>
  A python multiline string that specifies the cartesian coordinates of the atoms in the molecule. The format is as follows
  
  ```
  <Atom1>  <x1>  <y1>  <z1>;
  <Atom2>  <x2>  <y2>  <z2>;
  ...
  ```
</details>

<details>
  <summary><code>basis</code></summary>
  The name of the Gaussian basis set.
</details>

<details>
  <summary><code>wfn_sym</code></summary>
  The irrep of the wave function associated with the chosen value for <code>group</code> input. It accepts both the literal form e.g. <code>'Ag'</code>, <code>'B1'</code>, <code>'B2'</code>, <code>"'A'"</code>, <code>'"A"'</code>, as well as the integer form in PySCF notation where the trivial irrep is equal to 0. To get the complete list of the integer index equivalence of each irrep, consult the PySCF source file <code>&ltpyscf_root&gt/pyscf/symm/param.py</code>.
</details>

<details>
  <summary><code>prev_logbook</code></summary>
  The path to an existing logbook. This is used when you want to use the values of several input parameters from another simulation.
</details>

<details>
  <summary><code>nCore</code></summary>
  The number of core orbitals.
</details>

<details>
  <summary><code>nCAS</code></summary>
  The number of active orbitals.
</details>

<details>
  <summary><code>nelCAS</code></summary>
  The number of active electrons occupying the active orbitals.
</details>

<details>
  <summary><code>twos</code></summary>
  The result of 2*S where S is the total spin quantum number of the wave function.
</details>

<details>
  <summary><code>complex_MPS_type</code> (optional)</summary>
  <strong>Default</strong>: <code>'hybrid'</code>
  <br>
  The complex type of MPS in the calculation. The possible options are <code>'hybrid'</code> and <code>'full'</code>. For ground state and annihilation tasks, the choice of complex type should not matter. If they differ, then at least one of the simulations has not converged yet. For time evolution, the results will differ depending on the bond dimension. The two complex types should give identical time evolution dynamics when the bond dimension reaches convergence.
</details>

<details>
  <summary><code>dump_inputs</code> (optional)</summary>
  <strong>Default</strong>: <code>False</code>
  <br>
  If True, then the values of the input parameters will be printed to the output.
</details>

<details>
  <summary><code>memory</code> (optional)</summary>
  <strong>Default</strong>: <code>1E9</code>
  <br>
  Memory allocation in bytes for the entire run of the program.
</details>

<details>
  <summary><code>prefix</code> (optional)</summary>
  <strong>Default</strong>: The prefix of the input file if it has a <code>.py</code> extension, otherwise, the full name of the input file.
  <br>
  The prefix of files and folders created during simulation.
</details>

<details>
  <summary><code>verbose_lvl</code> (optional)</summary>
  <strong>Default</strong>: 4
  <br>
  A integer that controls the verbosity level of the output.
</details>

<details>
  <summary><code>ecp</code> (optional)</summary>
  <strong>Default</strong>: <code>None</code>
  <br>
  The effective core potential (ECP) on each atom. The format follows pyscf format for ECP. If not specified, no ECP will be used.
</details>

<details>
  <summary><code>group</code> (optional)</summary>
  <strong>Default</strong>: <code>'C1'</code>
  <br>
  A string that specifies the point group symmetry of the molecule.
</details>

<details>
  <summary><code>orb_path</code> (optional)</summary>
  <strong>Default</strong>: Hartee-Fock canonical orbitals using the chosen AO basis set and geometry.
  <br>
  Specifies the site orbitals. It accepts the path to a <code>*.npy</code> file that stores a 2D array (matrix) of the AO coefficients of the orbitals, where the rows refer to the AO index and the columns refer to the orbital index. The AO used to expand the orbitals should be the same as the AO chosen for the <code>basis</code> parameter. It also accepts <code>None</code>, for which case the program will treat it as if <code>orb_path</code> is not present (hence, will fall back to the default value).
</details>

<details>
  <summary><code>orb_order</code> (optional)</summary>
  <strong>Default</strong>: <code>'genetic'</code>
  <br>
  Specifies orbital ordering. The choices are as follows:
  <ol>
    <li>A string that specifies the path of a <code>*.npy</code> file containig a 1D array (vector) of integers representing the orbital index. These indices are 0-based.</li>
    <li>A list of 0-based integers. This is basically the hard-coded version of the first option above.</li>
    <li>A dictionary of the form
      <ol type="i">
	<li><code>{'type':'linear', 'direction':(x, y, z)}</code>, or</li>
	<li><code>{'type':'circular', 'plane':&lt3x3 matrix&gt}</code></li>
      </ol>
      The i format is for ordering based on a line in 3D space. In this ordering, the orbitals are ordered according to the projection of their dipole moments in the direction specified by the <code>'direction'</code> key. <code>x</code>, <code>y</code>, and <code>z</code> specifies the direction vector for the projection. The i format is best used for molecules whose one of the dimenions is clearly longer than the other. The ii format is for circular ordering, best for molecules exhibiting some form of circularity in shape, e.g. aromatic molecules. The value for <code>'plane'</code> is a 3x3 numpy matrix. This matrix specifies the coordinates of three points in space with which the plane of the circular ordering is defined. The rows of this matrix correspond to the three points, while the columns correrspond to their <code>x</code>, <code>y</code>, and <code>z</code> Cartesian components.
    </li>
    <li>A string 'genetic', the genetic algorithm.</li>
    <li>A string 'fiedler', the Fiedler algorithm.</li>
  </ol>
</details>

<details>
  <summary><code>mrci</code> (optional)</summary>
  <strong>Default</strong>: <code>None</code>
  <br>
  If given the format-conforming value, it prompts an MRCI calculation using MPS. The format is a dictionary with two entries, <code>'nactive2'</code> and <code>'order'</code>. <code>'nactive2'</code> specifies the number of the excitation orbitals. <code>'nactive2':10</code> means that the last 10 orbitals of the nCAS active orbitals are considered to be the excitation orbitals. <code>'order'</code> specifies the excitation order. Currently, the available options for <code>'order'</code> is 1, 2, and 3, representing single, single-double, and single-double-triple excitations, respectively.
</details>



# Input parameters for ground state calculation
<details>
  <summary><hl4><code>do_groundstate</code></hl4></summary>
  True or False. If True, a groundstate DMRG calculation will be performed.
</details>

<details>
  <summary><hl4><code>D_gs</code></hl4></summary>
  A list containing the schedule of the bond dimensions during DMRG iterations. For example, <code>[100]*2 + [200*4] + [300]</code>, means that the first two iterations use a max bond dimension of 100, the next four use 200 max bond dimension, and beyond that it uses the max bond dimension of 300 until convergence or maximum iteration number is reached, whichever is earlier.
</details>
<!--
  gs_inmps_dir:
    One of the three ways to construct a guess MPS for macro iterations. If it is set to
    a valid directory path, then the guess MPS is constructed using MPS files located under
    this directory. The default of the three ways is a randomly generated MPS having the
    prescribed maximum bond dimension.
  gs_inmps_fname:
    The file name of the info file of the MPS to be used to start the ground state DMRG
    iterations. This file should be inside the folder specified through gs_inmps_dir.
    This input must be present if gs_inmps_dir is present.
  gs_noise:
    A list containing the schedule of the noise applied during ground state iterations.
    A nonzero noise can be used to prevent the MPS from getting trapped in a local
    minimum. Its format follows the same convention as D_gs.
  gs_dav_tols:
    A list containing the schedule of the tolerances to terminate the Davidson/micro
    iterations for diagonlizing the effective Hamiltonian. Typically, it starts from a
    large value such as 0.01 and decrease until e.g. 1E-7. Its format follows the same
    convention as D_gs.
  gs_steps:
    The maximum number of macro iterations in the ground state calculation. Use this
    or gs_conv_tol to determine when to terminate the macro iteration.
  gs_conv_tol:
    The energy difference tolerance when the macro iterations should stop. Use this
    or gs_steps to determine when to terminate the macro iteration.
  gs_cutoff:
    States with eigenvalue below this number will be discarded, even when
    the bond dimension is large enough to keep this state.
  gs_occs:
    One of the three ways to construct a guess MPS for macro iterations. If it is set,
    then the guess MPS is constructed in such a way that its orbital occupancies are
    equal to gs_occs. It is a vector of nCAS floating point numbers. gs_occs is
    meaningless if gs_inmps_dir is set.
  gs_bias:
    A floating point number used to shift/bias the occupancies of active orbitals
    used to construct the guess MPS for macro iterations. If gs_bias is set, the
    given initial occupancies will be modified so that high occupancies are
    reduce by an gs_bias while low occupancies are increased by gs_bias. Only
    meaningful when gs_occs is given.
  gs_outmps_dir:
    The path to the directory in which the MPS files of the final ground state
    MPS will be saved for future use.
  gs_outmps_fname:
    The file name of the info file of the final ground state MPS This input must
    be present if gs_outmps_dir is present.
  save_gs_1pdm:
    True or False. If True, the one-particle RDM of the final ground state MPS
    will be saved under gs_outmps_dir with a filename GS_1pdm.npy.
  flip_spectrum:
    True or False. If True, the macro iterations will seek the highest energy
    of the Hamiltonian. It is implemented by running the same iterations as when
    this input is False but with a -1 multiplied into the Hamiltonian.
  gs_out_cpx:
    True or False. If True, the final ground state MPS will be converted to a
    full complex MPS where the tensor elements are purely real complex numbers.
    If True and complex_MPS_type is 'full', the program will be aborted.
#==== Annihilation operation parameters ====#
do_annihilate:
  True or False. If True, the program will calculate the annihilation of an electron
  from an orbital in the given input MPS.
  ann_sp:
    True or False. The spin projection of the annihilated electron, True means alpha
    electron, otherwise, beta electron.
  ann_orb:
    Specifies which orbital from which an electron is annihilated. It accepts an
    integer ranging from 0 to nCAS-1 and a nCAS-long vector. If it is given an
    integer, the program annihilates electron from the (ann_orb+1)-th orbital of
    the site. For example, ann_orb=2 means that the an electron will be annihilated
    from the third active orbital. If ann_orb is given a vector, the program will
    annihilate an electron from the orbital represented by the linear combination
    of the site orbitals where the expansion coefficients are contained in ann_orb.
    Note that small elements of ann_orb vector can cause execution error, therefore
    user should set small elements of ann_orb vector to exactly zero before running
    the program. Usually the threshold is 1E-5, that is, in this case do
           ann_orb[np.abs(ann_orb) < 1.0E-5] = 0.0
    The final ann_orb vector must be normalized. When ann_orb is a vector, the
    irrep of orbitals with large expansion coefficients must be the same. If
    classification between large and small coefficients is not possible (e.g. due
    to low contrast of these coefficients), then set group to a point group
    with less symmetries. Ultimately, group = 'C1' should cover
    ann_orb vector of no symmetry.
  D_ann_fit:
    A list containing the schedule of the bond dimensions during the fitting
    iterations. Its format follows the same convention as D_gs.
  ann_inmps_dir:
    The path to the directory containing the MPS files of the input MPS on
    which the annihilation operator will be applied.
  ann_inmps_fname:
    The file name of the info file of the input MPS on which the annihilation
    operator will be applied. ann_inmps_fname must be located under
    ann_inmps_dir.
  ann_outmps_dir:
    The path to the directory containing the MPS files of the output MPS.
  ann_outmps_fname:
    The file name of the info file of the output MPS. ann_outmps_fname must
    be located under ann_outmps_dir.
  ann_orb_thr:
    The threshold for determining the irrep of the orbital represented by
    ann_orb in vector form. The irrep of the annihilated orbital is
    equal to the irreps of orbitals whose absolute value of coefficient
    is higher than ann_orb_thr. This implies that the irrep of these
    large-coefficient orbitals must all be the same.
  LD try:
  LD     inputs['ann_fit_margin'] = ann_fit_margin
  LD except NameError:
  LD     inputs['ann_fit_margin'] = defvals.def_ann_fit_margin
  ann_fit_noise:
    A list containing the schedule of the noise applied during fitting iterations.
    A nonzero noise can be used to prevent the MPS from getting trapped in a local
    minimum. Its format follows the same convention as D_gs.
  ann_fit_tol:
    A threshold to determine when fitting iterations should stop.
  ann_fit_steps:
    The maximum number of iteration for the fitting iterations.
  ann_fit_cutoff:
    States with eigenvalue below this number will be discarded, even when
    the bond dimension is large enough to keep this state.
  ann_fit_occs:
    If it is set, the guess MPS for fitting iterations is constructed in such a way
    that its orbital occupancies are equal to ann_fit_occs. It is a vector of nCAS
    floating point numbers.
  ann_fit_bias:
    A floating point number used to shift/bias the occupancies of active orbitals
    used to construct the guess MPS for fitting iterations. If ann_fit_bias is set,
    the given initial occupancies will be modified so that high occupancies are
    reduce by an ann_fit_bias while low occupancies are increased by ann_fit_bias.
    Only meaningful when ann_fit_occs is given.
  normalize_annout:
    True or False. If True, the output MPS after annihilation is normalized.
  save_ann_1pdm:
    True or False. If True, the one-particle RDM of the output MPS will be saved
    under ann_outmps_dir with a filename ANN_1pdm.npy.
  ann_out_singlet_embed:
    True or False. If True, the output MPS will be converted to a singlet-
    embedding representation.
  ann_out_cpx:
    True or False. If True, the final output MPS will be converted to a full
    complex MPS where the tensor elements are purely real complex numbers.
    If True and complex_MPS_type is 'full', the program will be aborted.
#==== Time evolution parameters ====#
do_timeevo:
  True or False. If True, time evolution simulation using TDDMRG will be
  performed.
  te_max_D:
    The maximum bond dimension of the time-evolving MPS in the TDDMRG
    simulation.
  tmax:
    The maximum time up to which the time evolution is run.
  dt:
    The time step for time evolution in atomic unit of time.
  tinit:
    The initial time at which the time evolution starts. It only affects
    the time points printed at which observables are calculated and printed.
    It does not affect the simulation.
  te_inmps_dir:
    The path to the directory containing the MPS files of the initial MPS
    from which the time evolution starts.
  te_inmps_fname:
    The file name of the info file of the initial MPS from which the time
    evolution starts. te_inmps_fname must be located under te_inmps_dir.
  te_inmps_cpx:
    True or False. Set it to True if the initial MPS is complex, and
    False if the initial MPS is real. When restarting a TDDMRG simulation,
    regardless of the value of complex_MPS_type, this input must be set to
    True since the last MPS from the previous TDDMRG is complex. This
    input must also be set to True if the initial MPS is not from a
    previous TDDMRG simulation but complex_MPS_type is 'full', e.g. from
    an annihilation calculation with complex_MPS_type = 'full'.
  te_inmps_multi:
    True or False. Set it to True if the initial MPS is in state-average
    format, for example, when restarting from a previous TDDMRG simulation
    where complex_MPS_type = 'hybrid'. Set it to False otherwise.
  mps_act0_dir:
    The path to the directory containing the MPS files of the MPS used as
    the state at t=0 for the computation of autocorrelation function.
  mps_act0_fname:
    The file name of the info file of the MPS used as the state at t=0
    for the computation of autocorrelation function. This file must be
    located under the mps_act0_dir directory.
  mps_act0_cpx:
    True or False. It has the same meaning as te_inmps_cpx except for
    the MPS used as the state at t=0 for the computation of autocorrelation
    function.
  mps_act0_multi:
    True or False. It has the same meaning as te_inmps_multi except for
    the MPS used as the state at t=0 for the computation of autocorrelation
    function.
  te_method:
    The time propagation method. The available options are 'rk4' and 'tdvp'.
    'rk4' is stands for the time-step targeting (TST) method, while 'tdvp'
    stands for the time-dependent variational principle method (TDVP).
  exp_tol:
  te_cutoff:
    States with eigenvalue below this number will be discarded, even when
    the bond dimension is large enough to keep this state.
  krylov_size:
    The size of Krylov subspace used to approximate the action of a matrix
    exponential on a vector in TDVP propagation. Meaningless if
    te_method = 'rk4'.
  krylov_tol:
    A threshold used to set the accuracy of the Krylov subspace method in
    approximating the action of a matrix exponential on a vector in TDVP
    propagation.
  n_sub_sweeps:
    The number of sweeps in a TST propagation used to improve the
    renormalized basis in each time step.
  n_sub_sweeps_init:
    The number of sweeps in the first time step of a TST propagation used
    to improve the renormalized basis in each time step.
  te_normalize:
    True or False. If True, the MPS will be normalized after every time
    step.
  te_sample:
    The sampling time points around which the observables will be
    calculated and printed. It accepts three formats: a numpy vector of
    monotonically increasing time points, a tuple of the form
    ('steps', n) with n an integer, and a tuple of the form ('delta', d)
    with d a float. The ('steps', n) format is used to choose sampling 
    time points using a fixed interval n. n = 1 means that the observables
    are calculated and printed exactly every time step. n = 2 means that
    the observables are calculated and printed at every second time step.
    The ('delta', d) format is used to choose sampling time points at a
    fixed time interval. d = 0.01 means that the sampling time points are
    separated by 0.01 a.u. of time.
    Note that sampling times only tell the program approximately around
    which time points should observables be calculated. The actual time
    points when the observables are printed are those determined by dt
    which are the the closest to a particular te_sample. For example, if
    the only sampling time point is 12.6 and two propagation time points
    around it is 12.0 and 13.0, then the observables will be printed at
    t = 13.0. This means that the ('steps', n) format produces sampling 
    time points that are exactly a subset of the propagation time points.
    If dt contains non-uniform time steps, however, the ('steps', n)
    format will produce sampling time points which are not uniformly
    spaced (uniform spacing might desired for Fourier transform). To
    exact subset of the propagation time points which are not uniformly
    ensure uniformly spaced sampling points that are also the spaced (as
    is usually true because the first few time steps should typically be
    really short compared to at the later times), one can do
      dt = [DT/m]*m + [DT/n]*n + [DT]
      te_sample = ('delta', p*dt[-1])
    where m, n, and p are integers, while DT is a floating point.
  te_save_mps:
    Determines how often the instantaneous MPS should be saved. The
    available options are:
      1) 'overwrite'. MPS files are saved at the sampling time points
         under the folder <prefix>.mps_t where <prefix> is the value of
         prefix input. These MPS files overwrite the MPS files saved in
         the previous sampling time point.
      2) 'sampled'. MPS files are saved at every sampling time points.
         This option can lead to a huge space taken up by the MPS files.
         This option is usually used if you want to use these
         instantaneous MPS for later analyses that are not available
         already in this program and for which the use of 1RDM alone is
         not enough. If that is not your plan, using 'overwrite\' is 
         recommended.
      3) 'no'. MPS files will not be saved.
    Regardless of the value of te_save_mps, the instantaneous MPS can be
    saved 'on-demand' by using probe files.
  te_save_1pdm:
    True or False. If True, the 1-electron RDM is saved at every
    sampling time points under the folder <prefix>.sample where <prefix>
    is the value of prefix input.
  te_save_2pdm:
  save_txt:
  save_npy:
  te_in_singlet_embed:
    A 2-entry tuple of the form (True|False, n). Specify this input
    with the first entry set to True if the initial MPS is in singlet-
    embedding format, and n (second entry) set to the actual number of
    active electrons in the system. Due to the singlet-embedded form,
    the number of electrons in the initial MPS is adjusted so that the
    total spin can be zero.
  bo_pairs:
    Lowdin bond order.
###################################################)
-->
